# code_runner.py - CodeRunner + DeveloperAssistant for ClawForge

"""
ClawForge - CodeRunner + DeveloperAssistant
==========================================
Supports:
  - Python scripts
  - Node.js apps
  - Full-stack apps (React + FastAPI)
  - React dashboards
  - FastAPI / Flask backends
  - Automation scripts
  - Web scraping (ethical only)
  - AI agents / LLM wrappers for Ollama

Coding workflow:
  analyze → folder structure → write → test → debug → package

DeveloperAssistant:
  - Debug errors and explain logs
  - Optimize performance
  - Rewrite for better security
  - Document code
  - Write README.md
"""

import os
import sys
import ast
import json
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any, List

# ============================================================================
# PROJECT TEMPLATES
# ============================================================================

PYTHON_SCRIPT_TEMPLATE = '''#!/usr/bin/env python3
"""
{name} - {description}
Generated by ClawForge
"""

import argparse
import logging

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
logger = logging.getLogger(__name__)


def main(args):
    """Main entry point."""
    logger.info(f"Starting {name}...")
    # TODO: Implement core logic here
    print(f"Hello from {name}!")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="{description}")
    parser.add_argument("--verbose", action="store_true", help="Enable verbose output")
    args = parser.parse_args()
    main(args)
'''

FASTAPI_TEMPLATE = '''"""
{name} - FastAPI Backend
Generated by ClawForge
"""

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, List
import uvicorn

app = FastAPI(title="{name}", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)


# Models

class Item(BaseModel):
    id: Optional[int] = None
    name: str
    description: Optional[str] = None


# In-memory store

items: List[Item] = []


# Routes

@app.get("/")
async def root():
    return {{"status": "ok", "service": "{name}"}}


@app.get("/api/items")
async def get_items():
    return {{"items": items, "count": len(items)}}


@app.post("/api/items")
async def create_item(item: Item):
    item.id = len(items) + 1
    items.append(item)
    return {{"status": "created", "item": item}}


@app.get("/api/items/{{item_id}}")
async def get_item(item_id: int):
    for item in items:
        if item.id == item_id:
            return item
    raise HTTPException(status_code=404, detail="Item not found")


@app.delete("/api/items/{{item_id}}")
async def delete_item(item_id: int):
    global items
    items = [i for i in items if i.id != item_id]
    return {{"status": "deleted"}}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
'''

FLASK_TEMPLATE = '''"""
{name} - Flask Backend
Generated by ClawForge
"""

from flask import Flask, request, jsonify
from flask_cors import CORS

app = Flask(__name__)
CORS(app)

items = []


@app.route("/")
def root():
    return jsonify({{"status": "ok", "service": "{name}"}})


@app.route("/api/items", methods=["GET"])
def get_items():
    return jsonify({{"items": items}})


@app.route("/api/items", methods=["POST"])
def create_item():
    data = request.get_json()
    item = {{"id": len(items) + 1, **data}}
    items.append(item)
    return jsonify({{"status": "created", "item": item}}), 201


if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0", port=5000)
'''

REACT_APP_TEMPLATE = '''import {{ useState, useEffect }} from "react";

const API = "http://localhost:8000/api";

export default function App() {{
  const [items, setItems] = useState([]);
  const [name, setName] = useState("");
  const [loading, setLoading] = useState(false);

  const fetchItems = async () => {{
    const res = await fetch(`${{API}}/items`);
    const data = await res.json();
    setItems(data.items || []);
  }};

  const createItem = async () => {{
    if (!name.trim()) return;
    setLoading(true);
    await fetch(`${{API}}/items`, {{
      method: "POST",
      headers: {{ "Content-Type": "application/json" }},
      body: JSON.stringify({{ name }}),
    }});
    setName("");
    await fetchItems();
    setLoading(false);
  }};

  useEffect(() => {{ fetchItems(); }}, []);

  return (
    <div className="min-h-screen bg-gray-900 text-white p-8">
      <h1 className="text-3xl font-bold mb-6">{name}</h1>
      <div className="flex gap-3 mb-6">
        <input
          className="flex-1 bg-gray-800 border border-gray-600 rounded px-4 py-2"
          value={{name}}
          onChange={{e => setName(e.target.value)}}
          placeholder="Item name..."
        />
        <button
          onClick={{createItem}}
          disabled={{loading}}
          className="bg-blue-600 hover:bg-blue-500 px-6 py-2 rounded font-bold"
        >
          Add
        </button>
      </div>
      <div className="space-y-2">
        {{items.map(item => (
          <div key={{item.id}} className="bg-gray-800 rounded p-4">
            <span className="text-gray-400 mr-3">#{{item.id}}</span>
            {{item.name}}
          </div>
        ))}}
      </div>
    </div>
  );
}}
'''

OLLAMA_WRAPPER_TEMPLATE = '''"""
{name} - Ollama LLM Wrapper
Generated by ClawForge
"""

import requests
import json
from typing import Generator, Optional

OLLAMA_URL = "http://localhost:11434"
DEFAULT_MODEL = "llama3"


class OllamaWrapper:
    def __init__(self, model: str = DEFAULT_MODEL, base_url: str = OLLAMA_URL):
        self.model = model
        self.base_url = base_url

    def generate(self, prompt: str, system: Optional[str] = None) -> str:
        payload = {{"model": self.model, "prompt": prompt, "stream": False}}
        if system:
            payload["system"] = system
        resp = requests.post(f"{{self.base_url}}/api/generate", json=payload, timeout=120)
        return resp.json().get("response", "")

    def stream(self, prompt: str) -> Generator[str, None, None]:
        payload = {{"model": self.model, "prompt": prompt, "stream": True}}
        with requests.post(f"{{self.base_url}}/api/generate", json=payload, stream=True) as resp:
            for line in resp.iter_lines():
                if line:
                    chunk = json.loads(line)
                    yield chunk.get("response", "")
                    if chunk.get("done"):
                        break

    def chat(self, messages: list) -> str:
        payload = {{"model": self.model, "messages": messages, "stream": False}}
        resp = requests.post(f"{{self.base_url}}/api/chat", json=payload, timeout=120)
        return resp.json().get("message", {{}}).get("content", "")


if __name__ == "__main__":
    llm = OllamaWrapper()
    response = llm.generate("What is artificial intelligence in 2 sentences?")
    print(response)
'''

AUTOMATION_SCRIPT_TEMPLATE = '''"""
{name} - Automation Script
Generated by ClawForge
"""

import os
import time
import logging
import schedule
from pathlib import Path

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def task():
    """Define your automation task here."""
    logger.info("Running scheduled task...")
    # TODO: Add automation logic
    print(f"Task ran at {{time.strftime('%H:%M:%S')}}")


def main():
    logger.info("Starting {name} automation...")
    
    # Run immediately
    task()
    
    # Schedule to run every hour (modify as needed)
    schedule.every().hour.do(task)
    # schedule.every().day.at("09:00").do(task)
    
    logger.info("Scheduler active. Press Ctrl+C to stop.")
    while True:
        schedule.run_pending()
        time.sleep(60)


if __name__ == "__main__":
    main()
'''

REQUIREMENTS_MAP = {
    "fastapi": "fastapi\nuvicorn[standard]\npydantic\npython-multipart",
    "flask": "flask\nflask-cors",
    "scraping": "requests\nbeautifulsoup4\nplaywright\nlxml",
    "data": "pandas\nnumpy\nopenpyxl\nmatplotlib",
    "automation": "schedule\npython-dotenv",
    "ollama": "requests\nhttpx",
    "ai_agent": "requests\nfastapi\nuvicorn\npydantic",
    "general": "requests\npython-dotenv",
}

# ============================================================================
# CODE RUNNER CLASS
# ============================================================================

class CodeRunner:
    """
    Generates, writes, runs, and packages code projects.
    Coding workflow: analyze → structure → write → lint → test → package
    """
    
    SUPPORTED_TYPES = [
        "python_script", "fastapi", "flask", "react_app",
        "full_stack", "automation", "scraper", "ollama_wrapper", "ai_agent"
    ]

    def __init__(self, ollama_client=None):
        self.ollama = ollama_client
        
        # Get workspace paths
        try:
            from backend.identity import WORKSPACE_PATHS
            self.workspace_paths = WORKSPACE_PATHS
        except ImportError:
            self.workspace_paths = {
                "tasks": "./workspace/tasks",
                "output": "./workspace/output"
            }
    
    # ============================================================================
    # STEP 1: ANALYZE
    # ============================================================================
    
    def analyze_requirement(self, requirement: str) -> Dict[str, Any]:
        """Detects project type from user requirement."""
        req = requirement.lower()
        detected = "python_script"

        if "fastapi" in req or ("api" in req and "python" in req):
            detected = "fastapi"
        elif "flask" in req:
            detected = "flask"
        elif "react" in req or "frontend" in req or "dashboard" in req:
            detected = "react_app"
        elif ("full" in req and "stack" in req) or ("backend" in req and "frontend" in req):
            detected = "full_stack"
        elif "scrape" in req or "scraping" in req or "crawl" in req:
            detected = "scraper"
        elif "automat" in req or "schedule" in req or "cron" in req:
            detected = "automation"
        elif "ollama" in req or "llm" in req or "agent" in req:
            detected = "ollama_wrapper"

        return {
            "requirement": requirement,
            "detected_type": detected,
            "language": "JavaScript" if detected == "react_app" else "Python",
            "framework": detected,
            "recommended_model": "deepseek-coder",
        }
    
    # ============================================================================
    # STEP 2: FOLDER STRUCTURE
    # ============================================================================
    
    def generate_folder_structure(self, project_name: str, project_type: str, base_path: str) -> Dict[str, Any]:
        """Creates the complete folder structure for a project."""
        base = Path(base_path) / project_name
        structures = {
            "python_script": ["", "tests/", "docs/", "scripts/", "output/"],
            "fastapi": ["", "api/", "models/", "services/", "tests/", "docs/", "static/"],
            "flask": ["", "routes/", "models/", "templates/", "static/css/", "static/js/", "tests/"],
            "react_app": ["src/", "src/components/", "src/pages/", "src/hooks/", "src/styles/", "public/"],
            "full_stack": ["backend/", "backend/api/", "backend/models/", "frontend/src/", "frontend/src/components/", "frontend/src/pages/", "docs/"],
            "automation": ["", "scripts/", "logs/", "config/", "output/"],
            "scraper": ["", "scrapers/", "parsers/", "output/", "logs/"],
            "ollama_wrapper": ["", "agents/", "tools/", "memory/", "tests/"],
        }

        folders = structures.get(project_type, structures["python_script"])
        created = []
        for folder in folders:
            path = base / folder
            path.mkdir(parents=True, exist_ok=True)
            created.append(str(path.relative_to(base.parent)))

        return {
            "project_name": project_name,
            "project_type": project_type,
            "base_path": str(base),
            "folders_created": created,
        }
    
    # ============================================================================
    # STEP 3: WRITE CODE FILES
    # ============================================================================
    
    def write_project_files(
        self,
        project_name: str,
        project_type: str,
        base_path: str,
        description: str = "A ClawForge-generated project",
    ) -> List[str]:
        """Generates and writes all source files for the project."""
        base = Path(base_path) / project_name
        files_written = []
        name = project_name

        def write(rel_path: str, content: str):
            full = base / rel_path
            full.parent.mkdir(parents=True, exist_ok=True)
            full.write_text(content, encoding="utf-8")
            files_written.append(str(full))

        # Main files based on project type
        if project_type == "python_script":
            write("main.py", PYTHON_SCRIPT_TEMPLATE.format(name=name, description=description))
            write("requirements.txt", REQUIREMENTS_MAP["general"])

        elif project_type == "fastapi":
            write("main.py", FASTAPI_TEMPLATE.format(name=name))
            write("requirements.txt", REQUIREMENTS_MAP["fastapi"])

        elif project_type == "flask":
            write("main.py", FLASK_TEMPLATE.format(name=name))
            write("requirements.txt", REQUIREMENTS_MAP["flask"])

        elif project_type == "react_app":
            write("src/App.jsx", REACT_APP_TEMPLATE.format(name=name))
            write("src/main.jsx", 'import React from "react";\nimport ReactDOM from "react-dom/client";\nimport App from "./App";\nReactDOM.createRoot(document.getElementById("root")).render(<React.StrictMode><App /></React.StrictMode>);\n')
            write("index.html", f'<!DOCTYPE html>\n<html><head><title>{name}</title></head><body><div id="root"></div><script type="module" src="/src/main.jsx"></script></body></html>\n')
            write("package.json", json.dumps({
                "name": name.lower().replace(" ", "-"),
                "version": "1.0.0",
                "scripts": {"dev": "vite", "build": "vite build"},
                "dependencies": {"react": "^18.2.0", "react-dom": "^18.2.0"},
                "devDependencies": {"@vitejs/plugin-react": "^4.0.0", "vite": "^4.3.9", "tailwindcss": "^3.3.2"}
            }, indent=2))

        elif project_type == "full_stack":
            write("backend/main.py", FASTAPI_TEMPLATE.format(name=name))
            write("backend/requirements.txt", REQUIREMENTS_MAP["fastapi"])
            write("frontend/src/App.jsx", REACT_APP_TEMPLATE.format(name=name))
            write("frontend/package.json", json.dumps({
                "name": f"{name.lower()}-frontend",
                "scripts": {"dev": "vite"},
                "dependencies": {"react": "^18.2.0", "react-dom": "^18.2.0"},
                "devDependencies": {"@vitejs/plugin-react": "^4.0.0", "vite": "^4.3.9"}
            }, indent=2))

        elif project_type == "automation":
            write("main.py", AUTOMATION_SCRIPT_TEMPLATE.format(name=name))
            write("requirements.txt", REQUIREMENTS_MAP["automation"])

        elif project_type == "scraper":
            write("main.py", f'"""\n{name} - Web Scraper\nGenerated by ClawForge\n"""\n\nimport requests\nfrom bs4 import BeautifulSoup\nimport json\n\nBASE_URL = "https://example.com"\n\ndef scrape_page(url: str) -> dict:\n    headers = {{"User-Agent": "Mozilla/5.0"}}\n    resp = requests.get(url, headers=headers, timeout=15)\n    soup = BeautifulSoup(resp.text, "html.parser")\n    return {{"url": url, "title": soup.title.string if soup.title else ""}}\n\nif __name__ == "__main__":\n    result = scrape_page(BASE_URL)\n    print(json.dumps(result, indent=2))\n')
            write("requirements.txt", REQUIREMENTS_MAP["scraping"])

        elif project_type == "ollama_wrapper":
            write("main.py", OLLAMA_WRAPPER_TEMPLATE.format(name=name))
            write("requirements.txt", REQUIREMENTS_MAP["ollama"])

        # Shared files
        write("config.yaml", f"# {name} Configuration\nproject:\n  name: {name}\n  version: 1.0.0\n  description: {description}\n\napp:\n  debug: false\n  log_level: INFO\n")
        write("README.md", DeveloperAssistant.generate_readme(name, project_type, description))
        write(".gitignore", "__pycache__/\n*.pyc\n.env\nnode_modules/\ndist/\n.vite/\n*.log\n")
        write(".env.example", f"# {name} Environment Variables\nAPP_ENV=development\nDEBUG=false\nSECRET_KEY=changeme\n")

        return files_written
    
    # ============================================================================
    # STEP 4: LINT
    # ============================================================================
    
    def lint_python_file(self, file_path: str) -> Dict[str, Any]:
        """Runs AST syntax check on a Python file."""
        try:
            content = Path(file_path).read_text(encoding="utf-8")
            ast.parse(content)
            return {"status": "pass", "file": file_path, "issues": []}
        except SyntaxError as e:
            return {
                "status": "fail",
                "file": file_path,
                "issues": [{"Line": e.lineno, "message": str(e)}]
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}
    
    # ============================================================================
    # STEP 5: RUN TESTS
    # ============================================================================
    
    def run_python_file(self, file_path: str) -> Dict[str, Any]:
        """Safely runs a Python file inside workspace."""
        try:
            from backend.identity import WORKSPACE_ROOT
            workspace = Path(WORKSPACE_ROOT).resolve()
        except ImportError:
            workspace = Path("./workspace").resolve()
        
        safe = Path(file_path).resolve()
        try:
            safe.relative_to(workspace)
        except ValueError:
            return {"status": "blocked", "reason": "File is outside workspace."}

        result = subprocess.run(
            [sys.executable, str(safe)],
            capture_output=True, text=True,
            cwd=str(safe.parent), timeout=30
        )
        return {
            "status": "success" if result.returncode == 0 else "error",
            "stdout": result.stdout[:3000],
            "stderr": result.stderr[:1000],
            "returncode": result.returncode,
        }
    
    # ============================================================================
    # STEP 6: PACKAGE
    # ============================================================================
    
    def package_project(self, project_path: str, project_name: str) -> Dict[str, Any]:
        """Creates a summary manifest of all project files."""
        base = Path(project_path)
        all_files = list(base.rglob("*"))
        manifest = {
            "project_name": project_name,
            "packaged_at": datetime.utcnow().isoformat(),
            "total_files": len([f for f in all_files if f.is_file()]),
            "total_dirs": len([f for f in all_files if f.is_dir()]),
            "files": [str(f.relative_to(base)) for f in all_files if f.is_file()],
        }
        manifest_path = base / "MANIFEST.json"
        manifest_path.write_text(json.dumps(manifest, indent=2), encoding="utf-8")
        return manifest
    
    # ============================================================================
    # MASTER PIPELINE
    # ============================================================================
    
    def run_pipeline(
        self,
        requirement: str,
        project_name: str,
        task_id: str = "code_task",
    ) -> Dict[str, Any]:
        """
        Full coding pipeline:
        analyze → folder structure → write code → lint → package
        """
        print(f"\n[OK] CodeRunner Pipeline: '{project_name}'")

        try:
            output_base = Path(self.workspace_paths["output"]) / task_id
        except (KeyError, TypeError):
            output_base = Path("./workspace/output") / task_id

        # Step 1: Analyze
        print("  [1/5] Analyzing requirement...")
        analysis = self.analyze_requirement(requirement)
        project_type = analysis["detected_type"]
        print(f"         Detected: {project_type}")

        # Step 2: Folder structure
        print("  [2/5] Generating folder structure...")
        structure = self.generate_folder_structure(project_name, project_type, str(output_base))
        print(f"         Folders: {len(structure['folders_created'])}")

        # Step 3: Write files
        print("  [3/5] Writing code files...")
        files = self.write_project_files(
            project_name, project_type, str(output_base),
            description=requirement
        )
        print(f"         Files written: {len(files)}")

        # Step 4: Lint
        print("  [4/5] Linting...")
        lint_results = []
        for f in files:
            if f.endswith(".py"):
                result = self.lint_python_file(f)
                lint_results.append(result)
                status = "[OK]" if result["status"] == "pass" else "[WARN]"
                print(f"         {status} {Path(f).name}")

        # Step 5: Package
        print("  [5/5] Packaging...")
        manifest = self.package_project(
            str(output_base / project_name), project_name
        )
        print(f"         {manifest['total_files']} files packaged")

        print(f"  [OK] Project ready: {output_base / project_name}")
        return {
            "project_name": project_name,
            "project_type": project_type,
            "project_path": f"{output_base / project_name}",
            "files_written": files,
            "lint_results": lint_results,
            "manifest": manifest,
        }

# ============================================================================
# DEVELOPER ASSISTANT CLASS
# ============================================================================

class DeveloperAssistant:
    """
    Debugging, log explanation, performance optimization,
    security rewriting, code documentation, README generation.
    """
    
    # ============================================================================
    # DEBUG ERRORS
    # ============================================================================
    
    @staticmethod
    def debug_error(error_message: str, code_context: str = "") -> Dict[str, Any]:
        """Analyzes an error and suggests fixes."""
        error_lower = error_message.lower()
        suggestions = []
        root_cause = "Unknown error"
        fix = "Review the error message and check the relevant code section."

        if "modulenotfounderror" in error_lower or "no module named" in error_lower:
            module = error_message.split("'")[1] if "'" in error_message else "unknown"
            root_cause = f"Missing Python package: {module}"
            fix = f"Run: pip install {module}"
            suggestions = [f"pip install {module}", "Check requirements.txt for missing entries"]

        elif "syntaxerror" in error_lower:
            root_cause = "Python syntax error"
            fix = "Check the line number mentioned in the error."
            suggestions = ["Run ast.parse(code) to find exact location", "Check indentation"]

        elif "keyerror" in error_lower:
            key = error_message.split("'")[1] if "'" in error_message else "unknown"
            root_cause = f"Dictionary key not found: '{key}'"
            fix = f"Use `.get('{key}', default)` instead."
            suggestions = [f"Use: data.get('{key}')", "Add key validation before access"]

        elif "typeerror" in error_lower:
            root_cause = "Type mismatch error"
            fix = "Check the types of variables being passed."
            suggestions = ["Add type hints", "Use isinstance() checks"]

        elif "connectionrefused" in error_lower or "connection error" in error_lower:
            root_cause = "Network connection refused"
            fix = "Ensure the target service is running."
            suggestions = ["Check if server is running", "Verify host/port configuration"]

        elif "permission" in error_lower or "access denied" in error_lower:
            root_cause = "Permission denied"
            fix = "Check file/directory permissions."
            suggestions = ["Check file permissions", "Avoid writing outside workspace"]

        elif "timeout" in error_lower:
            root_cause = "Operation timed out"
            fix = "Increase timeout value or optimize operation."
            suggestions = ["Increase timeout", "Add retry logic"]

        return {
            "error": error_message[:200],
            "root_cause": root_cause,
            "suggested_fix": fix,
            "action_steps": suggestions,
            "code_context_provided": bool(code_context),
        }
    
    # ============================================================================
    # EXPLAIN LOGS
    # ============================================================================
    
    @staticmethod
    def explain_logs(log_text: str) -> Dict[str, Any]:
        """Parses and explains log output."""
        lines = log_text.strip().split("\n")
        errors = [l for l in lines if "ERROR" in l or "CRITICAL" in l]
        warnings = [l for l in lines if "WARNING" in l or "WARN" in l]
        info = [l for l in lines if "INFO" in l]

        summary = f"Log contains {len(lines)} lines: {len(errors)} errors, {len(warnings)} warnings, {len(info)} info messages."
        if errors:
            summary += f" Critical issues found: {errors[0][:100]}"

        return {
            "total_lines": len(lines),
            "errors": errors[:10],
            "warnings": warnings[:10],
            "info_count": len(info),
            "summary": summary,
            "health": "CRITICAL" if errors else "WARNING" if warnings else "OK",
        }
    
    # ============================================================================
    # OPTIMIZE CODE
    # ============================================================================
    
    @staticmethod
    def optimize_code(code: str) -> Dict[str, Any]:
        """Suggests performance optimizations for Python code."""
        suggestions = []

        if "for " in code and "range(len(" in code:
            suggestions.append("Replace 'for i in range(len(x))' with 'for item in x' or 'enumerate(x)'")
        if "+=" in code and "[" in code:
            suggestions.append("Consider using list comprehensions instead of loop appends")
        if "import *" in code:
            suggestions.append("Avoid 'import *' — import only what you need")
        if ".append(" in code and "for " in code:
            suggestions.append("Use list comprehension instead of loop+append")
        if "time.sleep" in code:
            suggestions.append("Consider asyncio for non-blocking waits")
        if not suggestions:
            suggestions.append("Code looks reasonably optimized.")

        return {
            "suggestions": suggestions,
            "count": len(suggestions),
            "profiling_tip": "Run: python -m cProfile -s cumulative your_script.py",
        }
    
    # ============================================================================
    # SECURITY REVIEW
    # ============================================================================
    
    @staticmethod
    def security_review(code: str) -> Dict[str, Any]:
        """Reviews code for common security vulnerabilities."""
        issues = []

        checks = [
            ("eval(", "HIGH", "Avoid eval() — it executes arbitrary code."),
            ("exec(", "HIGH", "Avoid exec() — it executes arbitrary code."),
            ("shell=True", "MEDIUM", "subprocess with shell=True is a command injection risk."),
            ("pickle.load", "HIGH", "pickle.load is unsafe with untrusted data."),
            ("os.system(", "MEDIUM", "Use subprocess.run() instead of os.system()."),
            ("password", "LOW", "Check that passwords are not hardcoded."),
            ("secret", "LOW", "Ensure secrets are loaded from environment variables."),
            ("TODO", "INFO", "Unfinished TODOs found."),
            ("http://", "LOW", "HTTP detected — use HTTPS."),
            ("0.0.0.0", "MEDIUM", "Binding to 0.0.0.0 exposes to all interfaces."),
        ]

        for pattern, severity, message in checks:
            if pattern.lower() in code.lower():
                issues.append({"pattern": pattern, "severity": severity, "message": message})

        risk = "HIGH" if any(i["severity"] == "HIGH" for i in issues) else \
               "MEDIUM" if any(i["severity"] == "MEDIUM" for i in issues) else \
               "LOW" if issues else "CLEAN"

        return {
            "issues_found": len(issues),
            "issues": issues,
            "overall_risk": risk,
        }
    
    # ============================================================================
    # DOCUMENT CODE
    # ============================================================================
    
    @staticmethod
    def document_code(code: str, file_name: str = "module") -> str:
        """Generates docstring documentation summary for a Python file."""
        lines = code.split("\n")
        functions = [l.strip() for l in lines if l.strip().startswith("def ")]
        classes = [l.strip() for l in lines if l.strip().startswith("class ")]

        doc = f"# Documentation: {file_name}\n\n"
        doc += f"Generated by ClawForge DeveloperAssistant — {datetime.utcnow().strftime('%Y-%m-%d')}\n\n"

        if classes:
            doc += "## Classes\n"
            for cls in classes:
                name = cls.replace("class ", "").split("(")[0].split(":")[0].strip()
                doc += f"- **`{name}`**: [Description needed]\n"

        if functions:
            doc += "\n## Functions\n"
            for fn in functions:
                name = fn.replace("def ", "").split("(")[0].strip()
                doc += f"- **`{name}()`**: [Description needed]\n"

        doc += f"\n## Summary\n"
        doc += f"- Lines of code: {len(lines)}\n"
        doc += f"- Functions: {len(functions)}\n"
        doc += f"- Classes: {len(classes)}\n"

        return doc
    
    # ============================================================================
    # GENERATE README
    # ============================================================================
    
    @staticmethod
    def generate_readme(project_name: str, project_type: str, description: str) -> str:
        """Generates a complete README.md for any project type."""
        now = datetime.utcnow().strftime("%Y-%m-%d")
        
        run_cmd_map = {
            "fastapi": "uvicorn main:app --reload",
            "flask": "python main.py",
            "react_app": "npm run dev",
            "automation": "python main.py",
            "scraper": "python main.py",
            "ollama_wrapper": "python main.py",
            "full_stack": "# Backend: cd backend && uvicorn main:app --reload\n# Frontend: cd frontend && npm run dev",
        }
        
        run_cmd = run_cmd_map.get(project_type, "python main.py")

        return f"""# {project_name}

> {description}

Generated by **ClawForge** — {now}

---

## Quick Start

```bash
cd {project_name.lower().replace(" ", "-")}

{"npm install" if project_type == "react_app" else "pip install -r requirements.txt"}

{run_cmd}
```

## Project Structure

```
{project_name}/
├── main.py          # Entry point
├── config.yaml      # Configuration
├── requirements.txt # Dependencies
├── README.md        # This file
└── .env.example     # Environment variables template
```

## Configuration

Copy `.env.example` to `.env` and fill in your values:

```bash
cp .env.example .env
```

## Development

- **Language**: {"JavaScript/TypeScript" if project_type == "react_app" else "Python"}
- **Framework**: {project_type.replace("_", " ").title()}
- **Generated**: {now}

## License

MIT License — Generated by ClawForge
"""

# ============================================================================
# CONVENIENCE FUNCTIONS
# ============================================================================

def run_code_project(
    requirement: str,
    project_name: str,
    task_id: str = "code_task",
    ollama_client = None
) -> Dict[str, Any]:
    """Convenience function to run the full code generation pipeline."""
    runner = CodeRunner(ollama_client=ollama_client)
    return runner.run_pipeline(requirement, project_name, task_id)

# ============================================================================
# TEST
# ============================================================================

if __name__ == "__main__":
    print("=" * 60)
    print("  CodeRunner + DeveloperAssistant Test")
    print("=" * 60)

    runner = CodeRunner()

    # Test 1: FastAPI project
    result = runner.run_pipeline(
        requirement="Build a FastAPI REST API with CRUD operations",
        project_name="MyFastAPI",
        task_id="test_code_001",
    )
    print(f"\n[OK] FastAPI project: {result['project_type']} - {len(result['files_written'])} files")

    # Test 2: Full-stack
    result2 = runner.run_pipeline(
        requirement="Create a full-stack React + Python app",
        project_name="MyFullStack",
        task_id="test_code_002",
    )
    print(f"[OK] Full-stack project: {result2['project_type']} - {len(result2['files_written'])} files")

    # Test 3: Developer Assistant
    print("\n[OK] DeveloperAssistant Tests:")
    err = DeveloperAssistant.debug_error("ModuleNotFoundError: No module named 'fastapi'")
    print(f"  Debug: {err['root_cause']} -> {err['suggested_fix']}")

    sec = DeveloperAssistant.security_review("result = eval(user_input)\nsubprocess.run(cmd, shell=True)")
    print(f"  Security: {sec['overall_risk']} - {sec['issues_found']} issues")

    opt = DeveloperAssistant.optimize_code("for i in range(len(items)):\n    result.append(items[i])")
    print(f"  Optimize: {opt['suggestions'][0][:60]}")

    readme = DeveloperAssistant.generate_readme("TestProject", "fastapi", "A test FastAPI service")
    print(f"  README: {len(readme)} chars generated")
